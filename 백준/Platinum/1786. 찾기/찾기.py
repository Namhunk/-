import sys

"""
# KMP(Knuth-Morris-Pratt) 알고리즘 공부, 시간복잡도 O(N+M)
# 문자열 검색을 매우 빠르게 해주는 알고리즘

# 첫째 줄에는 T 중간에 P가 몇 번 나타나는지 음이 아닌 정수 출력
# 둘째 줄에는 P가 나타나는 위치를 차례대로 공백으로 구분해 출력

# 문자열 T 입력
T = list(sys.stdin.readline().strip())
# 문자열 P 입력
P = list(sys.stdin.readline().strip())

# 파이 배열(실패 함수) = i번째 성분은, 문자열의 i 번째까지의 부분 문자열에서 접두사, 접미사가 같아지는 최대 길이
# 파이 배열을 활용해 동일성이 보장되는 구간을 빠르게 뛰어넘는다.
# 파이 배열 생성(내가 이해한대로 설명)
Pi = [0 for _ in range(len(P))] # Pi의 배열 생성

i = 0 # 반복문을 수행하며 현재까지 일치했던 문자열의 위치(길이)에 대한 정보를 저장하기 위한 변수

for j in range(1, len(P)): # 1번 위치부터 주어진 문자열의 마지막 위치까지 수행
    while i > 0 and Pi[i] != Pi[j]: # 이전에 일치하는 문자가 있었고, 현재 i, j 위치의 문자가 다르다면
        i = Pi[i-1] # i는 이전까지 일치했던 문자의 위치를 받음
    
    if Pi[i] == Pi[j]: # 두 문자가 일치하면
        i += 1 # i값은 다음 위치의 문자가 일치하는지 확인하기 위해 or 지금까지 일치한 문자의 위치(길이)를 저장하기 위해 + 1을 해줌
        Pi[j] = i # j의 위치에는 지금까지 일치한 문자열의 길이 or 마지막 문자의 위치를 넣어줌

ABAABA 문자열에 대한 위의 반복문을 실행한다 했을때

처음 P[i = 0], P[j = 1] (처음과 두번째 문자를 확인)
AB 는 서로 일치하지 않으므로 i는 움직이지 않고 j만 다음 위치로 이동 [0, 0, ...]
ABA는 0번 A, 2번 A가 일치하므로 i는 + 1이 되어 다음 1번 B가 일치하는지 확인
Pi[j = 2]에는 현재까지 일치한 문자열의 길이 1이 들어감 [0, 0, 1, ..]
P[i = 1] = B, P[j = 3] = A는 일치하지 않으므로 i의 P[i]와 P[j]가 일치할 때까지
i의 위치를 거꾸로 이동 i = 0 while 문의 i > 0, P[i = 0] != P[j == 3]를 만족하지 않기 때문에 while문에서 나옴
P[i = 0] = A, P[j = 3] = A, 일치 하므로 i + 1, Pi[j = 3] = 1, [0, 0, 1, 1, ...]
P[i = 1] = B, P[j = 4] = B, 일치 하므로 i + 1, Pi[j = 4] = 2, [0, 0, 1, 1, 2, ..]
P[i = 2] = A, P[j = 5] = A, 일치 하므로 i + 1  Pi[j = 5] = 3, [0, 0, 1, 1, 2, 3]
만약 일치하지 않는다면 P[i] == P[j]가 되는 문자까지 Pi[i-1]을 통해 i의 위치를 바꿔줌
만약 P[j = 5] = B 라고 가정한다면 while 문에서 i의 위치는 i = 2 -> Pi[i-1 = 1] = 1,
P[i = 1] = B 까지 i 위치를 이동, P[i = 1] = B, P[j = 5] = B 이므로 i + 1
P[j = 5] = 2, [0, 0, 1, 1, 2, 2] 가 된다.
"""

# 백준 1796번
# 문자열 T에 P가 몇번 나타나는지, P가 나타나는 위치들을 공백으로 구분해 출력

# T 입력
T = list(sys.stdin.readline())

# P 입력
P = list(sys.stdin.readline().rstrip())

# P에 대한 파이 배열 (실패 함수 배열 구하기)
Pi = [0 for _ in range(len(P))]
i = 0
for j in range(1, len(P)):
    while i > 0 and P[i] != P[j]:
        i = Pi[i-1]
    
    if P[i] == P[j]:
        i += 1
        Pi[j] = i

# 문자열 T와 P가 일치하는 부분이 있는지 확인
i = 0
ans = [] # 정답 배열
for j in range(len(T)):
    while i > 0 and P[i] != T[j]:
        i = Pi[i-1]
    
    if P[i] == T[j]:
        i += 1
        if i == len(P):
            ans.append(j-i+2)
            i = Pi[i-1]

print(len(ans))
if ans:
    print(*ans)